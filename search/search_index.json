{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Uniswap V3 Volatility Oracle Docs \u00b6 Volatility is defined as a measure of fluctuation in a quantity over a period of time. Volatility is a directionless measure i.e. market participants can use it to bet on amount of directionless variation in a price of an asset. VIX is a popular Volatility index used in traditional finance and has an average daily notional volume of ~400M last month. Oracles are data feeds that bring data from off the blockchain (off-chain) data sources and puts it on the blockchain (on-chain) for smart contracts to use. This is necessary because smart contracts running on Ethereum cannot access information stored outside the blockchain network. This repository builds an onchain oracle for calculating and exposing volatility across Uniswap pairs. How will this impact Uniswap ecosystem? This will bring a new use-case into the Uniswap periphery. If users can easily hedge their Impermanent loss then they can supply liquidity to non-stable-coin pairs. Currently Uniswap Protocol has $4.4B TVL $2.4B of which is due to 3 stable-coins (USDC, USDT DAI). The ability to hedge Impermanent loss will significantly increase non-stable-coin TVL. More liquidity means lesser slippage i.e. more trading volume and in turn more fees for the ecosystem. Why build a Decentralized Volatility Oracle? \u00b6 Although, decentralization brings the obvious and much talked about removal of centralization risk while building oracles. I would argue that decentralization adds another benefit i.e. scalability . Volatility Oracles built using UniV3 will be available for every token pair. This means that any new token or structured product can start integrating with the volatility Oracles from first Day. How it works? \u00b6 The contract stores accumulators which help in calculating Time Weighted Standard Deviation of ticks aka volatility for a UniV3 Pool. The pool already calculates accumulators to enable calculation of TWAP price by storing the tickCumulative this contract stores tickSquareCumulative which helps in calculating the volatility. More details can be found in the technical page .","title":"Home"},{"location":"#uniswap-v3-volatility-oracle-docs","text":"Volatility is defined as a measure of fluctuation in a quantity over a period of time. Volatility is a directionless measure i.e. market participants can use it to bet on amount of directionless variation in a price of an asset. VIX is a popular Volatility index used in traditional finance and has an average daily notional volume of ~400M last month. Oracles are data feeds that bring data from off the blockchain (off-chain) data sources and puts it on the blockchain (on-chain) for smart contracts to use. This is necessary because smart contracts running on Ethereum cannot access information stored outside the blockchain network. This repository builds an onchain oracle for calculating and exposing volatility across Uniswap pairs. How will this impact Uniswap ecosystem? This will bring a new use-case into the Uniswap periphery. If users can easily hedge their Impermanent loss then they can supply liquidity to non-stable-coin pairs. Currently Uniswap Protocol has $4.4B TVL $2.4B of which is due to 3 stable-coins (USDC, USDT DAI). The ability to hedge Impermanent loss will significantly increase non-stable-coin TVL. More liquidity means lesser slippage i.e. more trading volume and in turn more fees for the ecosystem.","title":"Uniswap V3 Volatility Oracle Docs"},{"location":"#why-build-a-decentralized-volatility-oracle","text":"Although, decentralization brings the obvious and much talked about removal of centralization risk while building oracles. I would argue that decentralization adds another benefit i.e. scalability . Volatility Oracles built using UniV3 will be available for every token pair. This means that any new token or structured product can start integrating with the volatility Oracles from first Day.","title":"Why build a Decentralized Volatility Oracle?"},{"location":"#how-it-works","text":"The contract stores accumulators which help in calculating Time Weighted Standard Deviation of ticks aka volatility for a UniV3 Pool. The pool already calculates accumulators to enable calculation of TWAP price by storing the tickCumulative this contract stores tickSquareCumulative which helps in calculating the volatility. More details can be found in the technical page .","title":"How it works?"},{"location":"development/","text":"Usage \u00b6 Pre Requisites \u00b6 Before being able to run any command, you need to create a .env file and set a BIP-39 compatible mnemonic as an environment variable. You can follow the example in .env.example . Then, proceed with installing dependencies: $ yarn install Compile \u00b6 Compile the smart contracts with Hardhat: $ yarn compile TypeChain \u00b6 Compile the smart contracts and generate TypeChain bindings: $ yarn typechain Test \u00b6 Run the tests with Hardhat: $ yarn test Coverage \u00b6 Generate the code coverage report: $ yarn coverage Report Gas \u00b6 See the gas usage per unit test and average gas per method call: $ REPORT_GAS=true yarn test Clean \u00b6 Delete the smart contract artifacts, the coverage reports and the Hardhat cache: $ yarn clean","title":"Development"},{"location":"development/#usage","text":"","title":"Usage"},{"location":"development/#pre-requisites","text":"Before being able to run any command, you need to create a .env file and set a BIP-39 compatible mnemonic as an environment variable. You can follow the example in .env.example . Then, proceed with installing dependencies: $ yarn install","title":"Pre Requisites"},{"location":"development/#compile","text":"Compile the smart contracts with Hardhat: $ yarn compile","title":"Compile"},{"location":"development/#typechain","text":"Compile the smart contracts and generate TypeChain bindings: $ yarn typechain","title":"TypeChain"},{"location":"development/#test","text":"Run the tests with Hardhat: $ yarn test","title":"Test"},{"location":"development/#coverage","text":"Generate the code coverage report: $ yarn coverage","title":"Coverage"},{"location":"development/#report-gas","text":"See the gas usage per unit test and average gas per method call: $ REPORT_GAS=true yarn test","title":"Report Gas"},{"location":"development/#clean","text":"Delete the smart contract artifacts, the coverage reports and the Hardhat cache: $ yarn clean","title":"Clean"},{"location":"howtouse/","text":"How to use this oracle? \u00b6 In traditional finance Realized Volatility is defined as the Standard Deviation of returns over a time period. Due to the way prices are stored in Uniswap contract, we calculate Volatility in a different way compared to Traditional Finance. We define Realized Volatility (RV) as the Time-Weighted Geometric Standard Deviation of Uniswap prices. The final formula for Realized Volatility is: \\[ RV = 1.001^{\\sqrt { \\frac{\\sum t_{ij} p_{ij}^2 - \\Delta t \\bar{p}^2 }{\\Delta t} }} \\] Where: \\(t_{ij}\\) : Time difference between two time stamps \\(t_i\\) and \\(t_j\\) \\(p_{ij}\\) : Price tick (as defined by UniV3 whitepaper) which remains constant between two time stamps \\(t_i\\) and \\(t_j\\) , i.e. remains constant for a total time period of \\(t_{ij}\\) \\(\\Delta t\\) : Total time between the start and end of the mean and variance calculation \\(\\bar{p}\\) : Time weighted Mean value of the price ticks in \\(\\Delta t\\) time period \\(RV\\) : Time weighted Geometric Stadard Deviation of the prices in time period Technical derivation can be found on the technical page . How are these values calculated? \u00b6 The Uniswap pair contract already stores the accumulator \\(\\Delta t p_{ij}\\) aka tickCumulative to calculate the Time-Weighted Geomteric mean. Similarly, to calculate the \\(RV\\) we need to calculate and store an extra accumulator i.e. \\(\\Delta t p_{ij}^2\\) aka tickSquareCumulative To store tickSquareCumulative the Volatility Oracle constantly pings the desired Uniswap Pair contract and stores these values in a struct called VolObservation using the function fillInObservations . struct VolObservation { /// @dev the block timestamp of the observation uint32 blockTimestamp; /// @dev the tick accumulator, i.e. tick * time elapsed since the pool was first initialized int56 tickCumulative; /// @dev the tick square accumulator, i.e. tick * tick * time elapsed since the oracle was first initialized uint112 tickSquareCumulative; } Finally, a downstream contract can just call the getVolByHours function on the VolOracle contract and get the values in a desired time-range. Is this active? \u00b6 Yes! The volatility contract is already live for ETH-Matic pair on polygon.","title":"How to use"},{"location":"howtouse/#how-to-use-this-oracle","text":"In traditional finance Realized Volatility is defined as the Standard Deviation of returns over a time period. Due to the way prices are stored in Uniswap contract, we calculate Volatility in a different way compared to Traditional Finance. We define Realized Volatility (RV) as the Time-Weighted Geometric Standard Deviation of Uniswap prices. The final formula for Realized Volatility is: \\[ RV = 1.001^{\\sqrt { \\frac{\\sum t_{ij} p_{ij}^2 - \\Delta t \\bar{p}^2 }{\\Delta t} }} \\] Where: \\(t_{ij}\\) : Time difference between two time stamps \\(t_i\\) and \\(t_j\\) \\(p_{ij}\\) : Price tick (as defined by UniV3 whitepaper) which remains constant between two time stamps \\(t_i\\) and \\(t_j\\) , i.e. remains constant for a total time period of \\(t_{ij}\\) \\(\\Delta t\\) : Total time between the start and end of the mean and variance calculation \\(\\bar{p}\\) : Time weighted Mean value of the price ticks in \\(\\Delta t\\) time period \\(RV\\) : Time weighted Geometric Stadard Deviation of the prices in time period Technical derivation can be found on the technical page .","title":"How to use this oracle?"},{"location":"howtouse/#how-are-these-values-calculated","text":"The Uniswap pair contract already stores the accumulator \\(\\Delta t p_{ij}\\) aka tickCumulative to calculate the Time-Weighted Geomteric mean. Similarly, to calculate the \\(RV\\) we need to calculate and store an extra accumulator i.e. \\(\\Delta t p_{ij}^2\\) aka tickSquareCumulative To store tickSquareCumulative the Volatility Oracle constantly pings the desired Uniswap Pair contract and stores these values in a struct called VolObservation using the function fillInObservations . struct VolObservation { /// @dev the block timestamp of the observation uint32 blockTimestamp; /// @dev the tick accumulator, i.e. tick * time elapsed since the pool was first initialized int56 tickCumulative; /// @dev the tick square accumulator, i.e. tick * tick * time elapsed since the oracle was first initialized uint112 tickSquareCumulative; } Finally, a downstream contract can just call the getVolByHours function on the VolOracle contract and get the values in a desired time-range.","title":"How are these values calculated?"},{"location":"howtouse/#is-this-active","text":"Yes! The volatility contract is already live for ETH-Matic pair on polygon.","title":"Is this active?"},{"location":"technical/","text":"Time weighted standard deviation \u00b6 Technical derivations \u00b6 We define and derive two methods for calculating Time Weighted Standard Deviation of Price Tick of a Uniswap v3 pair. This Standard deviation can be treated as a proxy for historical volatility between the two tokens. Key Definitions: \\(t_{ij}\\) : Time difference between two time stamps \\(t_i\\) and \\(t_j\\) \\(p_{ij}\\) : Price tick (as defined by UniV3 whitepaper) which remains constant between two time stamps \\(t_i\\) and \\(t_j\\) , i.e. remains constant for a total time period of \\(t_{ij}\\) \\(\\Delta t\\) : Total time between the start and end of the mean and variance calculation \\(\\bar{p}\\) : Time weighted Mean value of the price ticks in \\(\\Delta t\\) time period \\(s^2\\) : Time weighted Variance of the prices in time period Time Weighted Mean value \u00b6 The mean value of price ticks is \\[ \\bar{p} = \\frac{\\sum p_{ij}}{\\sum t} \\] The prices are actually constant between the time periods of \\(t_{ij}\\) so we can rewrite the above equation as: \\[ \\bar{p} = \\frac{\\sum t_{ij} p_{ij}}{\\Delta t} \\] Time Weighted Variance \u00b6 We can write the variance of the price tick between the preferred time period as: \\[ s^2 = \\frac{\\sum (p_{ij} - \\bar{p})^2}{\\sum t} \\] \\[ s^2 = \\frac{\\sum t_{ij} (p_{ij} - \\bar{p})^2}{\\Delta t } \\] \\[ s^2 = \\frac{\\sum t_{ij} (p_{ij}^2 - 2p_{ij}\\bar{p} + \\bar{p}^2)}{\\Delta t } \\] \\[ s^2 = \\frac{\\sum t_{ij} p_{ij}^2 - 2\\bar{p}\\sum t_{ij} p_{ij} + \\bar{p}^2 \\sum t_{ij}}{\\Delta t} \\] \\[ s^2 = \\frac{\\sum t_{ij} p_{ij}^2 - 2\\Delta t \\bar{p}^2 + \\Delta t\\bar{p}^2 }{\\Delta t} \\] \\[ s^2 = \\frac{\\sum t_{ij} p_{ij}^2 - \\Delta t \\bar{p}^2 }{\\Delta t} \\] The above formla for variance is numerically unstable when the standard deviation is very close to the mean value. Welford presented a more stable method for calculating the variance, we present the key formulas for that below. Welford Time Weighted Variance \u00b6 To calculate time weighted mean and variance we can also defer to welford method. Welford method defines an online method to calculate the variance, i.e. variance values are build based on the last mean and variance calculation. Key definitions \\(\\Delta t_{0,N}\\) : Time period between time \\(t_0\\) and \\(t_N\\) \\(\\bar{p}_{0,N}\\) : Time weighted Mean value of the price ticks in between time \\(t_0\\) and \\(t_N\\) time period \\(s^2_{0,N}\\) : Time weighted Variance of the prices ticks in between time \\(t_0\\) and \\(t_N\\) time period Time Weighted Mean value \u00b6 \\[ \\bar{p}_{0,N} = \\bar{p}_{0,N-1} + \\frac{\\Delta t_{N,N-1} \\times p_{N,N-1}}{\\Delta t_{0,N}} \\] The above formula lets us update the current value of mean based on the last value of mean, and new price tick between time \\(t_N\\) and \\(t_{N-1}\\) Welford defines \\(M\\) as: \\[ s^2 = \\frac{M}{\\Delta t} \\] \\[ M_{0,N} = M_{0,N-1} + \\Delta t_{N,N-1} (p_{N,N-1} - \\bar{p_{0,N-1}}) \\times (p_{N,N-1} - \\bar{p_{0,N}}) \\] One limitation for the welford formulation is that we need to know the mean values or time period of the variance calculation before. This means if we want to implement welford method we need to have one contract per time period.","title":"Technical"},{"location":"technical/#time-weighted-standard-deviation","text":"","title":"Time weighted standard deviation"},{"location":"technical/#technical-derivations","text":"We define and derive two methods for calculating Time Weighted Standard Deviation of Price Tick of a Uniswap v3 pair. This Standard deviation can be treated as a proxy for historical volatility between the two tokens. Key Definitions: \\(t_{ij}\\) : Time difference between two time stamps \\(t_i\\) and \\(t_j\\) \\(p_{ij}\\) : Price tick (as defined by UniV3 whitepaper) which remains constant between two time stamps \\(t_i\\) and \\(t_j\\) , i.e. remains constant for a total time period of \\(t_{ij}\\) \\(\\Delta t\\) : Total time between the start and end of the mean and variance calculation \\(\\bar{p}\\) : Time weighted Mean value of the price ticks in \\(\\Delta t\\) time period \\(s^2\\) : Time weighted Variance of the prices in time period","title":"Technical derivations"},{"location":"technical/#time-weighted-mean-value","text":"The mean value of price ticks is \\[ \\bar{p} = \\frac{\\sum p_{ij}}{\\sum t} \\] The prices are actually constant between the time periods of \\(t_{ij}\\) so we can rewrite the above equation as: \\[ \\bar{p} = \\frac{\\sum t_{ij} p_{ij}}{\\Delta t} \\]","title":"Time Weighted Mean value"},{"location":"technical/#time-weighted-variance","text":"We can write the variance of the price tick between the preferred time period as: \\[ s^2 = \\frac{\\sum (p_{ij} - \\bar{p})^2}{\\sum t} \\] \\[ s^2 = \\frac{\\sum t_{ij} (p_{ij} - \\bar{p})^2}{\\Delta t } \\] \\[ s^2 = \\frac{\\sum t_{ij} (p_{ij}^2 - 2p_{ij}\\bar{p} + \\bar{p}^2)}{\\Delta t } \\] \\[ s^2 = \\frac{\\sum t_{ij} p_{ij}^2 - 2\\bar{p}\\sum t_{ij} p_{ij} + \\bar{p}^2 \\sum t_{ij}}{\\Delta t} \\] \\[ s^2 = \\frac{\\sum t_{ij} p_{ij}^2 - 2\\Delta t \\bar{p}^2 + \\Delta t\\bar{p}^2 }{\\Delta t} \\] \\[ s^2 = \\frac{\\sum t_{ij} p_{ij}^2 - \\Delta t \\bar{p}^2 }{\\Delta t} \\] The above formla for variance is numerically unstable when the standard deviation is very close to the mean value. Welford presented a more stable method for calculating the variance, we present the key formulas for that below.","title":"Time Weighted Variance"},{"location":"technical/#welford-time-weighted-variance","text":"To calculate time weighted mean and variance we can also defer to welford method. Welford method defines an online method to calculate the variance, i.e. variance values are build based on the last mean and variance calculation. Key definitions \\(\\Delta t_{0,N}\\) : Time period between time \\(t_0\\) and \\(t_N\\) \\(\\bar{p}_{0,N}\\) : Time weighted Mean value of the price ticks in between time \\(t_0\\) and \\(t_N\\) time period \\(s^2_{0,N}\\) : Time weighted Variance of the prices ticks in between time \\(t_0\\) and \\(t_N\\) time period","title":"Welford Time Weighted Variance"},{"location":"technical/#time-weighted-mean-value_1","text":"\\[ \\bar{p}_{0,N} = \\bar{p}_{0,N-1} + \\frac{\\Delta t_{N,N-1} \\times p_{N,N-1}}{\\Delta t_{0,N}} \\] The above formula lets us update the current value of mean based on the last value of mean, and new price tick between time \\(t_N\\) and \\(t_{N-1}\\) Welford defines \\(M\\) as: \\[ s^2 = \\frac{M}{\\Delta t} \\] \\[ M_{0,N} = M_{0,N-1} + \\Delta t_{N,N-1} (p_{N,N-1} - \\bar{p_{0,N-1}}) \\times (p_{N,N-1} - \\bar{p_{0,N}}) \\] One limitation for the welford formulation is that we need to know the mean values or time period of the variance calculation before. This means if we want to implement welford method we need to have one contract per time period.","title":"Time Weighted Mean value"}]}